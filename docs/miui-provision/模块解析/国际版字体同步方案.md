---
layout: default
title: 国际版字体同步方案
parent: MiuiProvision项目文档
---

# 国际版字体同步方案

## 问题背景

在MIUI国际版开机向导中，用户在Google SetupWizard (GMS)中选择的字体（如Misans），进入MIUI字体选择页面后显示为"默认"，没有正确同步GMS的字体选择。

## 问题原因

### 原始实现问题

1. **生命周期方法错误**：字体恢复逻辑原本在`onActivityCreated()`中，但该方法在当前Fragment实现中未被正确调用
2. **读取方式错误**：依赖本地SharedPreferences和`DefaultPreferenceHelper.isFirstSetFont()`，没有读取系统实际使用的字体
3. **Bundle Key错误**：使用`bundle.getString("fonts")`而非正确的`bundle.getString("result")`

## 解决方案

### 核心原理

通过`ContentResolver`调用主题管理器的ContentProvider，读取系统当前使用的字体，并根据`isUsing:true`标志确定活跃字体。

### 实现步骤

#### 1. 在正确的生命周期方法中初始化

```java
@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
    // ... UI初始化 ...
    
    // 创建adapter并恢复字体选择状态
    ArrayList<FontInfo> fontList = new ArrayList<FontInfo>();
    fontList.add(new FontInfo(getResources().getString(R.string.default_font)));
    fontList.add(new FontInfo(getResources().getString(R.string.recommend_font), 
                 getResources().getString(R.string.recommended_font_mark)));
    mAdapter = new FontAdapter(getActivity(), fontList);
    
    // 从系统读取当前字体并恢复选择状态
    restoreSelectedFont();
    
    mRecyclerView.setAdapter(mAdapter);
}
```

#### 2. 从系统读取当前字体

```java
private void restoreSelectedFont() {
    Log.i(TAG, " restoreSelectedFont: START");
    // 优先从系统读取当前使用的字体（同步GMS选择）
    if (!readSystemCurrentFont()) {
        Log.w(TAG, " restoreSelectedFont: readSystemCurrentFont returned false, using fallback");
        // 系统读取失败，使用本地SP存储的字体（首次安装时返回DEFAULT_FONT_ID）
        boolean isDefault = TextUtils.equals(DEFAULT_FONT_ID, 
                           FontStyleUtils.getLocalFontId(ProvisionApplication.getContext()));
        mSelectedFont = getResources().getString(isDefault ? R.string.default_font 
                                                            : R.string.recommend_font);
        mCurrentFontId = isDefault ? DEFAULT_FONT_ID : MISANS_FONT_ID;
    }
    setFontCheckState();
}
```

#### 3. 解析系统字体JSON

```java
// 常量定义
private static final String KEY_RESULT = "result";

/**
 * 从系统字体管理器读取当前使用的字体（isUsing=true）
 * 
 * @return true if successfully read and set the current font, false otherwise
 */
private boolean readSystemCurrentFont() {
    try {
        Bundle bundle = mContext.getContentResolver().call(
                Uri.parse(URI), METHOD_GET_FONTS, null, null);
        if (bundle == null) {
            Log.w(TAG, "readSystemCurrentFont: bundle is null");
            return false;
        }
        
        String json = bundle.getString(KEY_RESULT);
        if (TextUtils.isEmpty(json)) {
            Log.w(TAG, "readSystemCurrentFont: json is empty");
            return false;
        }
        
        // 打印JSON用于调试
        Log.d(TAG, "readSystemCurrentFont: json=" + json);
        
        JSONArray jsonArray = new JSONArray(json);
        for (int i = 0; i < jsonArray.length(); i++) {
            JSONObject fontObj = jsonArray.getJSONObject(i);
            boolean isUsing = fontObj.optBoolean("isUsing", false);
            
            if (!isUsing) {
                continue;
            }
            
            String fontId = fontObj.optString("id");
            boolean isMisans = fontObj.optBoolean("isMisans", false);
            
            Log.i(TAG, "readSystemCurrentFont: found active font - id=" + fontId 
                      + ", isMisans=" + isMisans);
            
            if (isMisans) {
                MISANS_FONT_ID = fontId;
                mSelectedFont = getResources().getString(R.string.recommend_font);
                mCurrentFontId = fontId;
                return true;
            }
            
            if (TextUtils.equals(fontId, DEFAULT_FONT_ID)) {
                mSelectedFont = getResources().getString(R.string.default_font);
                mCurrentFontId = DEFAULT_FONT_ID;
                return true;
            }
        }
        
        Log.w(TAG, "readSystemCurrentFont: no active font found in JSON");
    } catch (Exception e) {
        Log.e(TAG, "readSystemCurrentFont: failed to parse font data", e);
    }
    return false;
}
```

### JSON格式说明

系统返回的字体列表JSON格式：

```json
[
  {
    "id": "10",
    "title": "默认",
    "isMisans": false,
    "isUsing": false,
    "isVariable": false,
    "rightFileUnaccessable": false
  },
  {
    "id": "45f50cbd-57af-45c3-baef-9ce73d23cad5",
    "title": "MiSans",
    "isMisans": true,
    "isUsing": true,
    "isVariable": true,
    "fontWeight": [150,200,250,305,340,400,480,540,630,700],
    "rightFileUnaccessable": false
  }
]
```

**关键字段：**
- `isUsing: true` - 表示当前系统正在使用的字体
- `isMisans: true` - 表示这是Misans字体
- `id` - 字体的唯一标识符

## GMS字体设置流程

1. **用户在GMS中选择字体**：通过Google SetupWizard的字体设置页面
2. **GMS调用系统API**：通过ContentResolver调用`com.android.thememanager.theme_provider`
3. **系统应用字体**：主题管理器将字体标记为`isUsing: true`
4. **MIUI读取字体**：通过`getFonts`方法获取字体列表，解析`isUsing`标志
5. **UI同步显示**：根据读取结果更新MIUI字体选择UI

## ContentProvider API

### URI
```
content://com.android.thememanager.theme_provider
```

### 方法
- `getFonts` - 获取所有字体列表及状态
- `applyFont` - 应用指定ID的字体（需要系统权限）

### 调用方式

```java
// 获取字体列表
Bundle bundle = getContentResolver().call(
    Uri.parse("content://com.android.thememanager.theme_provider"),
    "getFonts",
    null,
    null
);
String json = bundle.getString("result"); // 注意：key是"result"
```

## 测试验证

### 成功日志示例

```
10-10 19:41:54.935 I/FontStyleFragment: restoreSelectedFont: START
10-10 19:41:54.935 I/FontStyleFragment: readSystemCurrentFont: start
10-10 19:41:54.938 I/FontStyleFragment: readSystemCurrentFont: json=[...]
10-10 19:41:54.938 I/FontStyleFragment: readSystemCurrentFont: [1] id=45f50cbd..., isUsing=true
10-10 19:41:54.938 I/FontStyleFragment: readSystemCurrentFont: found using font - isMisans=true
10-10 19:41:54.938 I/FontStyleFragment: readSystemCurrentFont: SUCCESS - using Misans
10-10 19:41:54.947 I/FontStyleFragment: onViewCreated: AFTER restoreSelectedFont, mSelectedFont=MiSans
```

### 验证步骤

1. 在GMS中选择Misans字体
2. 进入MIUI字体选择页面
3. 确认"MiSans（推荐）"显示为已选中状态
4. 查看logcat确认`isUsing: true`正确解析

## 代码优化实践

### 优化要点

1. **常量提取**：将魔法字符串提取为常量
   ```java
   private static final String KEY_RESULT = "result";
   ```

2. **优化日志**：保留关键日志，简化冗余输出
   - 保留JSON内容日志（DEBUG级别，便于调试）
   - 保留活跃字体信息（INFO级别）
   - 保留警告和错误日志（WARN/ERROR级别）
   - 移除过于详细的循环日志

3. **规范import**：使用已导入的类而非完整路径
   - ✅ `JSONArray` / `JSONObject`
   - ❌ `org.json.JSONArray` / `org.json.JSONObject`

4. **JavaDoc注释**：为关键方法添加标准JavaDoc
   ```java
   /**
    * 从系统字体管理器读取当前使用的字体（isUsing=true）
    * 
    * @return true if successfully read and set the current font, false otherwise
    */
   ```

5. **早return模式**：减少嵌套层次，提高可读性
   ```java
   if (bundle == null) {
       return false;
   }
   ```

6. **异常处理简化**：统一的异常处理，避免重复代码

## 注意事项

1. **Bundle Key名称**：必须使用`KEY_RESULT`常量（值为`"result"`）
2. **生命周期方法**：必须在`onViewCreated()`而非`onActivityCreated()`中初始化
3. **异常处理**：系统API可能返回null或空JSON，需要完整的fallback逻辑
4. **字体ID动态性**：Misans的ID可能不同，应通过`isMisans: true`标志判断
5. **只读权限**：普通应用只能读取字体状态，无法调用`applyFont`设置字体

## 相关文件

- `src/com/android/provision/fragment/FontStyleFragment.java` - 字体选择Fragment
- `src/com/android/provision/utils/FontStyleUtils.java` - 字体工具类
- `docs/问题修复/国际版开机引导测试完整方案.md` - 完整测试方案

## 版本历史

- 2025-10-10: 初版 - 完成字体同步功能并验证成功


---
layout: default
title: 7. 安全与合规 (Security & Compliance)
parent: 模块解析
---



# 7. 安全与合规 (Security & Compliance)

## 7.1 数据安全

### 7.1.1 数据加密

#### 敏感数据加密

**Android Keystore使用**:
```java
public class KeystoreHelper {
    private static final String KEY_ALIAS = "provision_key";
    
    /**
     * 生成密钥
     */
    public static SecretKey generateKey() throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance(
            KeyProperties.KEY_ALGORITHM_AES, "AndroidKeyStore");
        
        KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(
            KEY_ALIAS,
            KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
            .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
            .setUserAuthenticationRequired(false)
            .build();
        
        keyGenerator.init(keyGenParameterSpec);
        return keyGenerator.generateKey();
    }
    
    /**
     * 加密数据
     */
    public static byte[] encrypt(String plainText) throws Exception {
        SecretKey secretKey = getKey();
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        
        byte[] iv = cipher.getIV();
        byte[] encrypted = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
        
        // 将IV和加密数据合并
        ByteBuffer byteBuffer = ByteBuffer.allocate(iv.length + encrypted.length);
        byteBuffer.put(iv);
        byteBuffer.put(encrypted);
        return byteBuffer.array();
    }
    
    /**
     * 解密数据
     */
    public static String decrypt(byte[] encryptedData) throws Exception {
        // 分离IV和加密数据
        ByteBuffer byteBuffer = ByteBuffer.wrap(encryptedData);
        byte[] iv = new byte[12];
        byteBuffer.get(iv);
        byte[] encrypted = new byte[byteBuffer.remaining()];
        byteBuffer.get(encrypted);
        
        SecretKey secretKey = getKey();
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(128, iv);
        cipher.init(Cipher.DECRYPT_MODE, secretKey, spec);
        
        byte[] decrypted = cipher.doFinal(encrypted);
        return new String(decrypted, StandardCharsets.UTF_8);
    }
}
```

#### 传输加密

**HTTPS配置**:
```java
public class SecureNetworkConfig {
    
    /**
     * 配置安全的OkHttpClient
     */
    public static OkHttpClient createSecureClient() {
        return new OkHttpClient.Builder()
            .connectionSpecs(Arrays.asList(
                ConnectionSpec.MODERN_TLS,
                ConnectionSpec.COMPATIBLE_TLS))
            .certificatePinner(createCertificatePinner())
            .hostnameVerifier(createHostnameVerifier())
            .build();
    }
    
    /**
     * 证书固定
     */
    private static CertificatePinner createCertificatePinner() {
        return new CertificatePinner.Builder()
            .add("api.miui.com", "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
            .add("api.miui.com", "sha256/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=")
            .build();
    }
    
    /**
     * 主机名验证
     */
    private static HostnameVerifier createHostnameVerifier() {
        return (hostname, session) -> {
            // 验证主机名
            return hostname.equals("api.miui.com") || 
                   hostname.endsWith(".miui.com");
        };
    }
}
```

**Network Security Configuration**:
```xml
<!-- res/xml/network_security_config.xml -->
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config cleartextTrafficPermitted="false">
        <domain includeSubdomains="true">api.miui.com</domain>
        <pin-set expiration="2025-12-31">
            <pin digest="SHA-256">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</pin>
            <pin digest="SHA-256">BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=</pin>
        </pin-set>
    </domain-config>
</network-security-config>
```

#### 存储加密

**EncryptedSharedPreferences**:
```java
public class SecurePreferences {
    private static final String PREFS_NAME = "secure_prefs";
    
    /**
     * 获取加密的SharedPreferences
     */
    public static SharedPreferences getEncrypted(Context context) {
        try {
            MasterKey masterKey = new MasterKey.Builder(context)
                .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
                .build();
            
            return EncryptedSharedPreferences.create(
                context,
                PREFS_NAME,
                masterKey,
                EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
            );
        } catch (Exception e) {
            Log.e(TAG, "Failed to create encrypted preferences", e);
            return null;
        }
    }
    
    /**
     * 保存敏感数据
     */
    public static void putSensitiveData(Context context, String key, String value) {
        SharedPreferences prefs = getEncrypted(context);
        if (prefs != null) {
            prefs.edit().putString(key, value).apply();
        }
    }
    
    /**
     * 读取敏感数据
     */
    public static String getSensitiveData(Context context, String key) {
        SharedPreferences prefs = getEncrypted(context);
        return prefs != null ? prefs.getString(key, null) : null;
    }
}
```

#### 密钥管理

**密钥生命周期管理**:
```java
public class KeyManagement {
    
    /**
     * 密钥轮换
     */
    public static void rotateKey() throws Exception {
        // 1. 生成新密钥
        SecretKey newKey = KeystoreHelper.generateKey("new_key_alias");
        
        // 2. 用新密钥重新加密数据
        List<SensitiveData> dataList = loadAllSensitiveData();
        for (SensitiveData data : dataList) {
            byte[] decrypted = decrypt(data.encrypted, oldKey);
            byte[] encrypted = encrypt(decrypted, newKey);
            data.encrypted = encrypted;
        }
        
        // 3. 删除旧密钥
        KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);
        keyStore.deleteEntry("old_key_alias");
    }
    
    /**
     * 密钥销毁
     */
    public static void destroyKey(String alias) throws Exception {
        KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);
        keyStore.deleteEntry(alias);
    }
}
```

---

### 7.1.2 权限管理

#### 权限申请

**运行时权限**:
```java
public class PermissionHelper {
    
    /**
     * 检查权限
     */
    public static boolean hasPermission(Context context, String permission) {
        return ContextCompat.checkSelfPermission(context, permission)
            == PackageManager.PERMISSION_GRANTED;
    }
    
    /**
     * 请求权限
     */
    public static void requestPermissions(Activity activity, 
                                         String[] permissions, 
                                         int requestCode) {
        List<String> needRequest = new ArrayList<>();
        
        for (String permission : permissions) {
            if (!hasPermission(activity, permission)) {
                needRequest.add(permission);
            }
        }
        
        if (!needRequest.isEmpty()) {
            ActivityCompat.requestPermissions(
                activity,
                needRequest.toArray(new String[0]),
                requestCode
            );
        }
    }
    
    /**
     * 处理权限结果
     */
    public static void handlePermissionResult(Activity activity,
                                             int requestCode,
                                             String[] permissions,
                                             int[] grantResults,
                                             PermissionCallback callback) {
        Map<String, Boolean> results = new HashMap<>();
        
        for (int i = 0; i < permissions.length; i++) {
            results.put(permissions[i], 
                grantResults[i] == PackageManager.PERMISSION_GRANTED);
        }
        
        callback.onResult(results);
    }
    
    public interface PermissionCallback {
        void onResult(Map<String, Boolean> results);
    }
}
```

**AndroidManifest权限声明**:
```xml
<!-- AndroidManifest.xml -->
<manifest>
    <!-- 系统级权限 -->
    <uses-permission android:name="android.permission.WRITE_SETTINGS" />
    <uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS" />
    
    <!-- 运行时权限 -->
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    
    <!-- 自定义权限 -->
    <permission
        android:name="android.provision.permission.SEND_PROVISION_COMPLETE_BROADCAST"
        android:protectionLevel="signatureOrSystem" />
</manifest>
```

#### 权限检查

**权限验证**:
```java
public class PermissionChecker {
    
    /**
     * 验证调用者权限
     */
    public static boolean checkCallingPermission(Context context, String permission) {
        int callingUid = Binder.getCallingUid();
        return context.checkPermission(permission, 
            Binder.getCallingPid(), callingUid) == PackageManager.PERMISSION_GRANTED;
    }
    
    /**
     * 验证签名级别权限
     */
    public static boolean checkSignaturePermission(Context context, String packageName) {
        PackageManager pm = context.getPackageManager();
        try {
            PackageInfo targetPackage = pm.getPackageInfo(packageName, 
                PackageManager.GET_SIGNATURES);
            PackageInfo currentPackage = pm.getPackageInfo(
                context.getPackageName(), PackageManager.GET_SIGNATURES);
            
            return Arrays.equals(
                targetPackage.signatures[0].toByteArray(),
                currentPackage.signatures[0].toByteArray()
            );
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }
}
```

#### 权限最小化

**最小权限原则**:
```java
public class MinimalPermissions {
    
    /**
     * 仅在需要时请求权限
     */
    public static void requestOnlyWhenNeeded(Activity activity) {
        // ❌ 错误：一次性请求所有权限
        // requestPermissions(activity, ALL_PERMISSIONS);
        
        // ✅ 正确：按需请求
        if (needCamera()) {
            requestPermissions(activity, new String[]{Manifest.permission.CAMERA});
        }
        
        if (needLocation()) {
            requestPermissions(activity, new String[]{
                Manifest.permission.ACCESS_FINE_LOCATION
            });
        }
    }
    
    /**
     * 使用最小权限完成任务
     */
    public static void useMinimalPermission() {
        // ❌ 错误：使用ACCESS_FINE_LOCATION获取粗略位置
        
        // ✅ 正确：粗略位置使用ACCESS_COARSE_LOCATION
        if (needCoarseLocation()) {
            // 使用ACCESS_COARSE_LOCATION
        }
    }
}
```

#### 运行时权限

**动态权限管理**:
```java
public class RuntimePermissionManager {
    
    @RequiresApi(api = Build.VERSION_CODES.M)
    public static void requestPermission(Activity activity, 
                                        String permission,
                                        int requestCode,
                                        String rationale) {
        if (activity.shouldShowRequestPermissionRationale(permission)) {
            // 显示权限说明
            new AlertDialog.Builder(activity)
                .setTitle("需要权限")
                .setMessage(rationale)
                .setPositiveButton("授权", (dialog, which) -> {
                    ActivityCompat.requestPermissions(activity,
                        new String[]{permission}, requestCode);
                })
                .setNegativeButton("取消", null)
                .show();
        } else {
            // 直接请求权限
            ActivityCompat.requestPermissions(activity,
                new String[]{permission}, requestCode);
        }
    }
}
```

---

### 7.1.3 安全存储

**使用案例**:
```java
// 存储账号Token
SecurePreferences.putSensitiveData(context, "auth_token", token);

// 读取账号Token
String token = SecurePreferences.getSensitiveData(context, "auth_token");

// 删除敏感数据
SecurePreferences.getEncrypted(context).edit().remove("auth_token").apply();
```

**数据清理**:
```java
public class DataCleaner {
    
    /**
     * 清理敏感数据
     */
    public static void clearSensitiveData(Context context) {
        // 1. 清除加密SharedPreferences
        SharedPreferences prefs = SecurePreferences.getEncrypted(context);
        if (prefs != null) {
            prefs.edit().clear().apply();
        }
        
        // 2. 清除数据库
        context.deleteDatabase("provision.db");
        
        // 3. 清除缓存文件
        deleteDir(context.getCacheDir());
        
        // 4. 清除内部存储
        deleteDir(context.getFilesDir());
    }
    
    private static void deleteDir(File dir) {
        if (dir != null && dir.isDirectory()) {
            File[] files = dir.listFiles();
            if (files != null) {
                for (File file : files) {
                    if (file.isDirectory()) {
                        deleteDir(file);
                    } else {
                        file.delete();
                    }
                }
            }
        }
    }
}
```

---

## 7.2 隐私保护

### 7.2.1 GDPR合规

#### 用户同意

**同意机制实现**:
```java
public class ConsentManager {
    private static final String KEY_CONSENT_VERSION = "consent_version";
    private static final int CURRENT_CONSENT_VERSION = 2;
    
    /**
     * 检查是否需要重新获取同意
     */
    public static boolean needsConsent(Context context) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
        int savedVersion = prefs.getInt(KEY_CONSENT_VERSION, 0);
        return savedVersion < CURRENT_CONSENT_VERSION;
    }
    
    /**
     * 显示同意对话框
     */
    public static void showConsentDialog(Activity activity, ConsentCallback callback) {
        new AlertDialog.Builder(activity)
            .setTitle("隐私政策更新")
            .setMessage("我们更新了隐私政策，请阅读并同意继续使用。\n\n" +
                "我们收集以下数据：\n" +
                "- 设备信息（型号、系统版本）\n" +
                "- 使用数据（功能使用情况）\n" +
                "- 诊断数据（崩溃日志）\n\n" +
                "您可以随时在设置中撤回同意。")
            .setPositiveButton("同意", (dialog, which) -> {
                saveConsent(activity, true);
                callback.onConsent(true);
            })
            .setNegativeButton("拒绝", (dialog, which) -> {
                callback.onConsent(false);
            })
            .setCancelable(false)
            .show();
    }
    
    /**
     * 保存同意状态
     */
    private static void saveConsent(Context context, boolean agreed) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
        prefs.edit()
            .putInt(KEY_CONSENT_VERSION, CURRENT_CONSENT_VERSION)
            .putBoolean("data_collection_consent", agreed)
            .putLong("consent_timestamp", System.currentTimeMillis())
            .apply();
    }
    
    public interface ConsentCallback {
        void onConsent(boolean agreed);
    }
}
```

#### 数据收集透明度

**数据收集声明**:
```java
public class DataCollectionPolicy {
    
    /**
     * 获取数据收集说明
     */
    public static String getDataCollectionDescription() {
        return "MIUI开机引导收集以下数据：\n\n" +
            "1. 基本信息\n" +
            "   - 设备型号\n" +
            "   - 系统版本\n" +
            "   - 应用版本\n\n" +
            "2. 使用数据\n" +
            "   - 功能使用情况\n" +
            "   - 用户选择（语言、输入法等）\n" +
            "   - 完成时间\n\n" +
            "3. 诊断数据\n" +
            "   - 崩溃日志\n" +
            "   - 性能数据\n" +
            "   - 错误报告\n\n" +
            "4. 用途\n" +
            "   - 改善用户体验\n" +
            "   - 修复Bug\n" +
            "   - 性能优化\n\n" +
            "我们不会收集：\n" +
            "- 个人身份信息\n" +
            "- 联系人\n" +
            "- 短信内容\n" +
            "- 通话记录";
    }
    
    /**
     * 显示数据收集详情
     */
    public static void showDataCollectionDetails(Activity activity) {
        new AlertDialog.Builder(activity)
            .setTitle("数据收集详情")
            .setMessage(getDataCollectionDescription())
            .setPositiveButton("确定", null)
            .setNeutralButton("隐私政策", (dialog, which) -> {
                // 打开隐私政策页面
                openPrivacyPolicy(activity);
            })
            .show();
    }
}
```

#### 用户权利保护

**数据访问权**:
```java
public class UserRightsManager {
    
    /**
     * 导出用户数据
     */
    public static File exportUserData(Context context) throws IOException {
        JSONObject data = new JSONObject();
        
        try {
            // 1. 基本信息
            data.put("device_model", Build.MODEL);
            data.put("android_version", Build.VERSION.RELEASE);
            
            // 2. 用户选择
            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
            data.put("selected_language", prefs.getString("language", ""));
            data.put("selected_input_method", prefs.getString("input_method", ""));
            
            // 3. 使用记录
            data.put("setup_time", prefs.getLong("setup_time", 0));
            data.put("completion_time", prefs.getLong("completion_time", 0));
            
        } catch (JSONException e) {
            throw new IOException("Failed to export data", e);
        }
        
        // 写入文件
        File exportFile = new File(context.getExternalFilesDir(null), "user_data.json");
        FileWriter writer = new FileWriter(exportFile);
        writer.write(data.toString(2));
        writer.close();
        
        return exportFile;
    }
    
    /**
     * 删除用户数据
     */
    public static void deleteUserData(Context context) {
        // 1. 删除SharedPreferences
        PreferenceManager.getDefaultSharedPreferences(context)
            .edit().clear().apply();
        
        // 2. 删除数据库
        context.deleteDatabase("provision.db");
        
        // 3. 删除文件
        deleteDir(context.getFilesDir());
        deleteDir(context.getCacheDir());
    }
}
```

#### 数据处理合规

**GDPR合规检查清单**:
- [x] 获取明确同意
- [x] 提供清晰的隐私政策
- [x] 允许用户撤回同意
- [x] 提供数据导出功能
- [x] 提供数据删除功能
- [x] 数据最小化收集
- [x] 数据加密存储和传输
- [x] 数据保留期限明确

---

### 7.2.2 隐私政策

**隐私政策模板**:
```markdown
# MIUI开机引导隐私政策

最后更新日期：2025-10-17

## 1. 数据收集

我们收集以下类型的数据：

### 1.1 自动收集的数据
- 设备信息：型号、制造商、系统版本
- 应用信息：应用版本、安装时间
- 使用数据：功能使用情况、完成时间

### 1.2 用户主动提供的数据
- 语言选择
- 输入法选择
- 地区设置

## 2. 数据使用

我们使用收集的数据用于：
- 提供和改善服务
- 修复Bug和技术问题
- 进行数据分析和统计

## 3. 数据共享

我们不会将您的数据出售给第三方。
我们可能与以下方共享数据：
- 小米集团关联公司
- 服务提供商（云存储、分析服务）

## 4. 数据安全

我们采取以下安全措施：
- 数据加密传输（TLS/SSL）
- 数据加密存储
- 访问控制和权限管理
- 定期安全审计

## 5. 您的权利

您有权：
- 访问您的数据
- 更正不准确的数据
- 删除您的数据
- 反对数据处理
- 数据可携带

## 6. 联系我们

如有隐私问题，请联系：
- 邮箱：privacy@miui.com
- 电话：400-100-5678
```

---

### 7.2.3 用户同意

**同意管理UI**:
```java
public class ConsentActivity extends Activity {
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_consent);
        
        TextView policyText = findViewById(R.id.policy_text);
        policyText.setText(getPrivacyPolicy());
        
        CheckBox consentCheckbox = findViewById(R.id.consent_checkbox);
        Button agreeButton = findViewById(R.id.agree_button);
        Button disagreeButton = findViewById(R.id.disagree_button);
        
        // 必须勾选才能同意
        consentCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            agreeButton.setEnabled(isChecked);
        });
        
        agreeButton.setOnClickListener(v -> {
            ConsentManager.saveConsent(this, true);
            setResult(RESULT_OK);
            finish();
        });
        
        disagreeButton.setOnClickListener(v -> {
            ConsentManager.saveConsent(this, false);
            setResult(RESULT_CANCELED);
            finish();
        });
    }
}
```

---

## 7.3 代码安全

### 7.3.1 混淆策略

#### ProGuard配置

**主要混淆规则** (proguard.flags):
```proguard
# 优化配置
-optimizationpasses 5
-dontusemixedcaseclassnames
-dontskipnonpubliclibraryclasses
-dontpreverify
-verbose

# 保留注解
-keepattributes Exceptions,InnerClasses,Signature,Deprecated,
                SourceFile,LineNumberTable,*Annotation*,EnclosingMethod

# 保留应用类
-keep class com.android.provision*.** { *; }

# 保留Activity的onClick方法
-keepclassmembers class com.android.provision*.** extends android.app.Activity {
    public void *(android.view.View);
    public void *(android.view.MenuItem);
}

# 保留View的setter/getter（用于动画）
-keep public class com.android.provision*.** extends android.view.View {
    public <init>(android.content.Context);
    public <init>(android.content.Context, android.util.AttributeSet);
    public <init>(android.content.Context, android.util.AttributeSet, int);
    void set*(***);
    *** get*();
}

# 保留Parcelable
-keepclassmembers class * implements android.os.Parcelable {
    public static final *;
}

# 保留R类资源
-keepclasseswithmembers class com.android.provision.R$* {
    *;
}

# 保留第三方库
-keep class com.google.protobuf.** { *; }
-dontwarn com.google.protobuf.**

-keep class miui.** { *; }
-dontwarn miui.**

# 保留native方法
-keepclasseswithmembers class ** {
    native <methods>;
}
```

#### R8优化

**R8配置** (gradle.properties):
```properties
# 启用R8完整模式
android.enableR8.fullMode=true

# 启用资源缩减
android.enableResourceOptimizations=true
```

#### 混淆规则

**反混淆映射**:
```bash
# 生成混淆映射文件
./gradlew assembleRelease

# 映射文件位置
app/build/outputs/mapping/release/mapping.txt

# 使用retrace还原堆栈
retrace.sh mapping.txt stacktrace.txt
```

#### 反混淆

**保留关键类不混淆**:
```proguard
# 保留AIDL接口
-keep interface com.android.provision.** { *; }

# 保留数据模型（用于序列化）
-keep class com.android.provision.beans.** { *; }

# 保留JS接口
-keepclassmembers class * {
    @android.webkit.JavascriptInterface <methods>;
}
```

---

### 7.3.2 签名验证

#### APK签名

**签名配置**:
```gradle
android {
    signingConfigs {
        debug {
            keyAlias 'miuiclock'
            keyPassword 'android'
            storeFile file('.keystore')
            storePassword 'android'
        }
        
        release {
            keyAlias System.getenv("KEY_ALIAS")
            keyPassword System.getenv("KEY_PASSWORD")
            storeFile file(System.getenv("KEYSTORE_FILE"))
            storePassword System.getenv("KEYSTORE_PASSWORD")
            v1SigningEnabled true
            v2SigningEnabled true
            v3SigningEnabled true
        }
    }
    
    buildTypes {
        release {
            signingConfig signingConfigs.release
        }
    }
}
```

#### 签名校验

**运行时签名验证**:
```java
public class SignatureVerifier {
    
    /**
     * 验证APK签名
     */
    public static boolean verifySignature(Context context) {
        try {
            PackageManager pm = context.getPackageManager();
            PackageInfo packageInfo = pm.getPackageInfo(
                context.getPackageName(),
                PackageManager.GET_SIGNATURES
            );
            
            Signature[] signatures = packageInfo.signatures;
            if (signatures == null || signatures.length == 0) {
                return false;
            }
            
            // 验证签名摘要
            String currentSignature = getSignatureHash(signatures[0]);
            String expectedSignature = getExpectedSignatureHash();
            
            return currentSignature.equals(expectedSignature);
        } catch (Exception e) {
            Log.e(TAG, "Signature verification failed", e);
            return false;
        }
    }
    
    /**
     * 获取签名哈希
     */
    private static String getSignatureHash(Signature signature) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(signature.toByteArray());
            return Base64.encodeToString(md.digest(), Base64.NO_WRAP);
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
    }
    
    /**
     * 获取预期的签名哈希
     */
    private static String getExpectedSignatureHash() {
        // 从安全存储或硬编码获取
        return "EXPECTED_SIGNATURE_HASH";
    }
}
```

#### 防重打包

**完整性检查**:
```java
public class IntegrityChecker {
    
    /**
     * 检查APK完整性
     */
    public static boolean checkIntegrity(Context context) {
        // 1. 验证签名
        if (!SignatureVerifier.verifySignature(context)) {
            return false;
        }
        
        // 2. 检查安装来源
        if (!checkInstallSource(context)) {
            return false;
        }
        
        // 3. 检查DEX完整性
        if (!checkDexIntegrity(context)) {
            return false;
        }
        
        return true;
    }
    
    /**
     * 检查安装来源
     */
    private static boolean checkInstallSource(Context context) {
        PackageManager pm = context.getPackageManager();
        String installer = pm.getInstallerPackageName(context.getPackageName());
        
        // 允许的安装来源
        return installer == null ||  // 预装应用
               installer.equals("com.android.vending") ||  // Google Play
               installer.equals("com.xiaomi.market");  // 小米应用商店
    }
    
    /**
     * 检查DEX完整性
     */
    private static boolean checkDexIntegrity(Context context) {
        try {
            ApplicationInfo appInfo = context.getApplicationInfo();
            String sourceDir = appInfo.sourceDir;
            
            // 计算APK的哈希值
            File apkFile = new File(sourceDir);
            String apkHash = calculateFileHash(apkFile);
            
            // 与预期哈希对比
            String expectedHash = getExpectedApkHash();
            return apkHash.equals(expectedHash);
        } catch (Exception e) {
            return false;
        }
    }
}
```

#### 完整性检查

**CRC校验**:
```java
public class CRCChecker {
    
    /**
     * 计算文件CRC
     */
    public static long calculateCRC(File file) throws IOException {
        CRC32 crc = new CRC32();
        try (FileInputStream fis = new FileInputStream(file)) {
            byte[] buffer = new byte[8192];
            int bytesRead;
            while ((bytesRead = fis.read(buffer)) != -1) {
                crc.update(buffer, 0, bytesRead);
            }
        }
        return crc.getValue();
    }
    
    /**
     * 验证文件完整性
     */
    public static boolean verifyFileCRC(File file, long expectedCRC) {
        try {
            long actualCRC = calculateCRC(file);
            return actualCRC == expectedCRC;
        } catch (IOException e) {
            return false;
        }
    }
}
```

---

### 7.3.3 防逆向

#### 代码混淆

**高级混淆技巧**:
```proguard
# 1. 类名混淆
-repackageclasses 'a.b.c'

# 2. 重命名
-flattenpackagehierarchy 'com.android.provision'

# 3. 优化
-optimizations !code/simplification/arithmetic,!code/simplification/cast,!field/*,!class/merging/*

# 4. 删除日志
-assumenosideeffects class android.util.Log {
    public static *** v(...);
    public static *** d(...);
    public static *** i(...);
}
```

#### 资源加密

**Assets加密**:
```java
public class AssetsEncryption {
    
    /**
     * 加密Assets文件
     */
    public static void encryptAsset(File inputFile, File outputFile, SecretKey key) 
        throws Exception {
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        
        try (FileInputStream fis = new FileInputStream(inputFile);
             FileOutputStream fos = new FileOutputStream(outputFile)) {
            
            // 写入IV
            byte[] iv = cipher.getIV();
            fos.write(iv);
            
            // 加密并写入
            byte[] buffer = new byte[8192];
            int bytesRead;
            while ((bytesRead = fis.read(buffer)) != -1) {
                byte[] encrypted = cipher.update(buffer, 0, bytesRead);
                if (encrypted != null) {
                    fos.write(encrypted);
                }
            }
            
            byte[] finalBytes = cipher.doFinal();
            if (finalBytes != null) {
                fos.write(finalBytes);
            }
        }
    }
    
    /**
     * 解密Assets文件
     */
    public static byte[] decryptAsset(InputStream is, SecretKey key) throws Exception {
        // 读取IV
        byte[] iv = new byte[12];
        is.read(iv);
        
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(128, iv);
        cipher.init(Cipher.DECRYPT_MODE, key, spec);
        
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] buffer = new byte[8192];
        int bytesRead;
        
        while ((bytesRead = is.read(buffer)) != -1) {
            byte[] decrypted = cipher.update(buffer, 0, bytesRead);
            if (decrypted != null) {
                baos.write(decrypted);
            }
        }
        
        byte[] finalBytes = cipher.doFinal();
        if (finalBytes != null) {
            baos.write(finalBytes);
        }
        
        return baos.toByteArray();
    }
}
```

#### SO库保护

**Native代码保护**:
```cpp
// JNI函数动态注册
JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {
    JNIEnv* env;
    if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) {
        return JNI_ERR;
    }
    
    // 动态注册native方法
    jclass clazz = env->FindClass("com/android/provision/JNIUtils");
    if (clazz == nullptr) {
        return JNI_ERR;
    }
    
    JNINativeMethod methods[] = {
        {"nativeMethod", "()V", (void*)nativeMethod}
    };
    
    env->RegisterNatives(clazz, methods, sizeof(methods) / sizeof(methods[0]));
    
    return JNI_VERSION_1_6;
}

// 反调试检测
bool isDebuggable() {
    // 检查TracerPid
    FILE* status = fopen("/proc/self/status", "r");
    if (status == nullptr) {
        return false;
    }
    
    char line[256];
    while (fgets(line, sizeof(line), status)) {
        if (strncmp(line, "TracerPid:", 10) == 0) {
            int pid = atoi(line + 10);
            fclose(status);
            return pid != 0;
        }
    }
    
    fclose(status);
    return false;
}
```

#### 反调试

**反调试检测**:
```java
public class AntiDebug {
    
    /**
     * 检测调试器
     */
    public static boolean isDebuggerConnected() {
        return Debug.isDebuggerConnected() || Debug.waitingForDebugger();
    }
    
    /**
     * 检测模拟器
     */
    public static boolean isEmulator() {
        return Build.FINGERPRINT.startsWith("generic")
            || Build.FINGERPRINT.startsWith("unknown")
            || Build.MODEL.contains("google_sdk")
            || Build.MODEL.contains("Emulator")
            || Build.MODEL.contains("Android SDK built for x86")
            || Build.MANUFACTURER.contains("Genymotion")
            || (Build.BRAND.startsWith("generic") && Build.DEVICE.startsWith("generic"))
            || "google_sdk".equals(Build.PRODUCT);
    }
    
    /**
     * 检测Root
     */
    public static boolean isRooted() {
        // 检查su命令
        String[] paths = {
            "/system/app/Superuser.apk",
            "/sbin/su",
            "/system/bin/su",
            "/system/xbin/su",
            "/data/local/xbin/su",
            "/data/local/bin/su",
            "/system/sd/xbin/su",
            "/system/bin/failsafe/su",
            "/data/local/su"
        };
        
        for (String path : paths) {
            if (new File(path).exists()) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * 检测Xposed
     */
    public static boolean isXposedActive() {
        try {
            throw new Exception();
        } catch (Exception e) {
            for (StackTraceElement element : e.getStackTrace()) {
                if (element.getClassName().contains("de.robv.android.xposed")) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

---

## 文档信息

- **文档版本**: v1.0
- **创建日期**: 2025-10-17
- **最后更新**: 2025-10-17
- **文档状态**: 正式版
- **维护者**: MIUI开发团队
- **相关文档**:
  - [00-模块解析大纲.md](./00-模块解析大纲.md)
  - [06-质量保证.md](./06-质量保证.md)
  - [08-运维与监控.md](./08-运维与监控.md)


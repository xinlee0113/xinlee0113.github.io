---
layout: default
title: BUGOS2-721450 字体设置页面条件显示需求方案
parent: 问题修复
---



# BUGOS2-721450 字体设置页面条件显示需求方案

## 📋 问题信息

**问题单号**: [BUGOS2-721450](https://jira-phone.mioffice.cn/browse/BUGOS2-721450)  
**问题标题**: 【提测】O82在更改文字显示方式中将字体改为MiSans后,进入字体设置页面勾选的还是Default  
**问题类型**: 需求（原为Bug）  
**优先级**: 严重  
**组件**: 开机引导 Provision  

---

## 🎯 需求描述

### 原始问题
用户在Google开机设置流程中设置了MiSans字体，但进入小米开机引导的字体设置页面后，显示的仍然是Default字体被选中。

### 转需求后的要求
**产品需求**（周珊珊 2025-10-20 15:07）：
> 转为需求，新增判断：
> - **如果用户在谷歌页面设置过字体，则小米字体页面隐藏**
> - **若没有在谷歌页面设置过字体，小米字体页面展示**

### 复现条件
- **测试类型**: 用例测试
- **复现概率**: 必现
- **前提条件**: 登录谷歌账号
- **复现步骤**:
  1. 在Google开机设置的"更改文字显示方式"中将字体改为MiSans
  2. 继续进行开机引导至小米字体设置页面
- **预期结果**: 小米字体设置页面不显示（已在Google设置过）
- **当前实际结果**: 仍然展示小米字体设置页面，且MiSans未被选中

---

## 🔍 技术分析

### 1. 当前代码逻辑

#### 1.1 FontState状态机
**位置**: `src/com/android/provision/global/GlobalDefaultActivity.java`

```java
public static class FontState extends State {
    @Override
    public boolean isAvailable(boolean toNext) {
        Log.i(TAG, " here is FontState isAvailable func ");
        return Utils.isMiSansSupportLanguages() 
                && FontStyleFragment.getFontList(context).size()==2 
                && !Utils.isFoldDevice() 
                && !Utils.isInProvisionState(context);
    }
}
```

**当前判断条件**：
1. ✅ 当前语言支持MiSans字体
2. ✅ 字体列表正好有2个（Default + MiSans）
3. ✅ 不是折叠屏设备
4. ✅ 不在企业配置模式

#### 1.2 字体应用逻辑
**位置**: `src/com/android/provision/global/GlobalDefaultActivity.java` - `CongratulationState`

```java
public static class CongratulationState extends State {
    @Override
    public void onLeave() {
        super.onLeave();
        if (Build.IS_INTERNATIONAL_BUILD && FontStyleUtils.DEFAULT_FONT_ID.equalsIgnoreCase(FontStyleUtils.getLocalFontId(context))) {
            FontStyleUtils.applyFont(context, FontStyleUtils.DEFAULT_FONT_ID);
        } else {
            FontStyleUtils.applyFont(context, FontStyleUtils.MISANS_FONT_ID);
        }
        // ... 其他逻辑
    }
}
```

### 2. 问题根因

**核心问题**: 当前的`FontState.isAvailable()`方法**没有检查用户是否已在Google设置向导中设置过字体**。

即使用户在Google流程中已经设置了字体，小米的字体设置页面仍然会展示，且由于小米本地保存的字体偏好是默认值（Default），导致页面上Default被选中，而不是用户在Google设置的MiSans。

---

## 💡 技术方案

### 方案一：检测系统当前字体配置（推荐）⭐

#### 核心思路
通过`ThemeManager`的ContentProvider查询当前系统正在使用的字体ID，如果发现系统字体已经不是Default（说明在Google流程中设置过），则隐藏小米字体设置页面。

#### 实现步骤

##### 步骤1: 在`FontStyleUtils.java`中添加检测方法

```java
/**
 * 检测系统当前是否已应用非默认字体
 * 用于判断用户是否在Google设置流程中修改过字体
 * 
 * @param context 上下文
 * @return true-系统已设置非默认字体（Google流程设置过）, false-仍是默认字体
 */
public static boolean hasSystemFontBeenChanged(Context context) {
    try {
        // 方法1: 通过ThemeManager查询当前系统字体
        Bundle extras = new Bundle();
        Bundle bundle = context.getContentResolver().call(
            Uri.parse(URI), 
            "getCurrentFont",  // 需要确认ThemeManager支持的方法名
            null, 
            extras
        );
        
        if (bundle != null) {
            String currentFontId = bundle.getString("fontId");
            Log.i(TAG, "System current font ID: " + currentFontId);
            
            // 如果当前系统字体ID不是默认字体，说明已在Google流程中设置过
            if (currentFontId != null && !DEFAULT_FONT_ID.equals(currentFontId)) {
                return true;
            }
        }
        
        // 方法2: 通过读取系统属性（备用方案）
        String sysFontConfig = android.os.SystemProperties.get("persist.sys.font_config", "");
        if (!TextUtils.isEmpty(sysFontConfig) && !sysFontConfig.equals("default")) {
            Log.i(TAG, "System font config changed: " + sysFontConfig);
            return true;
        }
        
        // 方法3: 通过检测系统Settings（最可靠）
        // Google Setup Wizard设置字体后，可能会写入Settings.System或Settings.Secure
        String settingsFontId = Settings.System.getString(
            context.getContentResolver(), 
            "font_id"  // 实际key需要根据GMS实现确认
        );
        if (settingsFontId != null && !DEFAULT_FONT_ID.equals(settingsFontId)) {
            Log.i(TAG, "Settings font ID changed: " + settingsFontId);
            return true;
        }
        
    } catch (Exception e) {
        Log.e(TAG, "Error checking system font status", e);
    }
    
    return false;  // 默认返回false，表示未检测到字体变更
}
```

##### 步骤2: 修改`FontState.isAvailable()`方法

**位置**: `src/com/android/provision/global/GlobalDefaultActivity.java`

```java
public static class FontState extends State {
    @Override
    public boolean isAvailable(boolean toNext) {
        Log.i(TAG, " here is FontState isAvailable func ");
        
        // 基础条件检查
        if (!Utils.isMiSansSupportLanguages() 
                || FontStyleFragment.getFontList(context).size() != 2 
                || Utils.isFoldDevice() 
                || Utils.isInProvisionState(context)) {
            Log.i(TAG, "FontState: basic conditions not met");
            return false;
        }
        
        // 🆕 新增：检查用户是否在Google流程中已设置字体
        if (FontStyleUtils.hasSystemFontBeenChanged(context)) {
            Log.i(TAG, "FontState: font already set in Google flow, hiding MIUI font page");
            return false;  // 用户已在Google设置过字体，隐藏小米字体页面
        }
        
        Log.i(TAG, "FontState: showing MIUI font page");
        return true;
    }
}
```

#### 优点
✅ 逻辑清晰，直接检测系统状态  
✅ 不依赖Google流程的内部实现  
✅ 即使Google流程变更，只要字体已应用到系统，就能正确检测  
✅ 实现简单，风险可控

#### 缺点
⚠️ 需要确认ThemeManager ContentProvider支持的查询方法  
⚠️ 需要确认Google设置字体后是否立即应用到系统  

---

### 方案二：检测Google Setup完成状态（备选）

#### 核心思路
检测用户是否完成了Google Setup Wizard的字体设置步骤。

#### 实现方法

```java
/**
 * 检测用户是否在Google Setup中完成了字体设置
 */
public static boolean hasGoogleFontSetupCompleted(Context context) {
    try {
        // Google Setup可能会设置特定的标记
        int googleSetupComplete = Settings.Secure.getInt(
            context.getContentResolver(),
            "google_font_setup_complete",  // 需要确认实际的key
            0
        );
        
        if (googleSetupComplete == 1) {
            return true;
        }
        
        // 或者检查Google Setup整体完成状态
        int gmsSetupComplete = Settings.Secure.getInt(
            context.getContentResolver(),
            "setup_wizard_completed",  // Google的标准key
            0
        );
        
        // 如果Google Setup已完成，且当前字体不是默认值
        if (gmsSetupComplete == 1 && hasSystemFontBeenChanged(context)) {
            return true;
        }
        
    } catch (Exception e) {
        Log.e(TAG, "Error checking Google font setup status", e);
    }
    
    return false;
}
```

#### 优点
✅ 直接检测Google流程状态  
✅ 逻辑明确

#### 缺点
❌ 依赖Google Setup的内部实现细节  
❌ Google可能没有提供公开的API  
❌ 不同GMS版本可能实现不同  
❌ 维护成本高

---

### 方案三：通过SharedPreferences跨进程通信（不推荐）

#### 核心思路
期望Google Setup在设置字体后写入某个共享标记，小米流程读取该标记。

#### 缺点
❌ 需要修改Google Setup代码（不可行）  
❌ 跨应用通信复杂且不可靠  
❌ 无法实施

---

## 🎯 推荐实施方案

### **最终方案：方案一（系统字体检测）**

#### 实施步骤详解

##### 第一步：调研确认关键信息

在实施前，需要先确认以下信息：

1. **确认ThemeManager ContentProvider支持的方法**
   ```bash
   # 通过adb查看ThemeManager支持的方法
   adb shell content query --uri content://com.android.thememanager.theme_provider
   ```

2. **确认Google设置字体的时机**
   - 在测试设备上，在Google流程中设置字体
   - 使用`dumpsys activity`和`dumpsys settings`查看系统状态变化
   - 确认字体是否立即应用到系统

3. **确认系统字体存储位置**
   ```bash
   # 查看系统字体相关的Settings
   adb shell settings list system | grep font
   adb shell settings list secure | grep font
   adb shell settings list global | grep font
   
   # 查看系统属性
   adb shell getprop | grep font
   ```

##### 第二步：代码实现

**文件1**: `src/com/android/provision/utils/FontStyleUtils.java`

```java
package com.android.provision.utils;

import android.content.Context;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Bundle;
import android.provider.Settings;
import android.text.TextUtils;
import android.util.Log;

import com.android.provision.DefaultPreferenceHelper;

public class FontStyleUtils {
    private static final String TAG = "FontStyleUtils";

    private static final String AUTHORITY = "com.android.thememanager.theme_provider";
    private static final String URI = "content://" + AUTHORITY;
    //应用字体
    private static final String METHOD_APPLY_FONT = "applyFont";
    //获取当前字体
    private static final String METHOD_GET_CURRENT_FONT = "getCurrentFont";

    private static String LOCAL_FONT_SP = "LOCAL_FONT_SP";
    public static final String CURRENT_FONT_ID = "current_font_id";
    public static final String DEFAULT_FONT_ID = "10";

    public static String MISANS_FONT_ID = null;

    /**
     * 应用全局字体
     */
    public static void applyFont(final Context context, final String fontId) {
        ThreadUtils.postOnBackgroundThread(()->{
            final boolean[] result = {false};
            Bundle extras = new Bundle();
            extras.putString("fontId", fontId);
            try {
                Bundle bundle = context.getContentResolver().call(Uri.parse(URI), METHOD_APPLY_FONT, null, extras);
                Log.i(TAG, " bundle is " + bundle);
                result[0] = bundle.getBoolean("applyResult");
                Log.i(TAG, " result[0] is " + result[0]);
                DefaultPreferenceHelper.setFirstSetFont(false);
            } catch (Exception e) {
                result[0] = false;
                e.printStackTrace();
            }
        });
    }

    public static String getLocalFontId(Context context) {
        SharedPreferences sharedPreferences = context.getSharedPreferences(LOCAL_FONT_SP, Context.MODE_PRIVATE);
        return sharedPreferences.getString(CURRENT_FONT_ID, DEFAULT_FONT_ID);
    }

    public static void setLocalFontId(Context context, String currentId) {
        SharedPreferences sharedPreferences = context.getSharedPreferences(LOCAL_FONT_SP, Context.MODE_PRIVATE);
        SharedPreferences.Editor editor = sharedPreferences.edit();
        editor.putString(CURRENT_FONT_ID, currentId);
        editor.apply();
    }

    /**
     * 检测系统当前是否已应用非默认字体
     * 用于判断用户是否在Google设置流程中修改过字体
     * 
     * @param context 上下文
     * @return true-系统已设置非默认字体（Google流程可能设置过）, false-仍是默认字体
     */
    public static boolean hasSystemFontBeenChanged(Context context) {
        Log.i(TAG, "Checking if system font has been changed...");
        
        try {
            // 方法1: 通过ThemeManager查询当前系统正在使用的字体
            Bundle bundle = context.getContentResolver().call(
                Uri.parse(URI), 
                METHOD_GET_CURRENT_FONT, 
                null, 
                null
            );
            
            if (bundle != null) {
                String currentFontId = bundle.getString("fontId");
                Log.i(TAG, "ThemeManager current font ID: " + currentFontId);
                
                // 如果当前系统字体ID不是默认字体，说明已在Google流程中设置过
                if (currentFontId != null && !DEFAULT_FONT_ID.equals(currentFontId)) {
                    Log.i(TAG, "System font changed detected via ThemeManager");
                    return true;
                }
            }
        } catch (Exception e) {
            Log.w(TAG, "Failed to query current font from ThemeManager", e);
        }
        
        try {
            // 方法2: 检查系统属性（备用检测）
            String sysFontConfig = android.os.SystemProperties.get("persist.sys.font_config", "");
            Log.i(TAG, "System property persist.sys.font_config: " + sysFontConfig);
            
            if (!TextUtils.isEmpty(sysFontConfig) && !sysFontConfig.equals("default")) {
                Log.i(TAG, "System font changed detected via system property");
                return true;
            }
        } catch (Exception e) {
            Log.w(TAG, "Failed to read system property", e);
        }
        
        try {
            // 方法3: 检查是否有第三方设置了字体（通过检测字体包名）
            String fontPackage = Settings.System.getString(
                context.getContentResolver(), 
                "theme_font_package"
            );
            Log.i(TAG, "Settings theme_font_package: " + fontPackage);
            
            if (!TextUtils.isEmpty(fontPackage)) {
                Log.i(TAG, "Third-party font package detected");
                return true;
            }
        } catch (Exception e) {
            Log.w(TAG, "Failed to check font package from Settings", e);
        }
        
        Log.i(TAG, "No font change detected, system using default font");
        return false;
    }
}
```

**文件2**: `src/com/android/provision/global/GlobalDefaultActivity.java`

修改`FontState`类：

```java
public static class FontState extends State {
    @Override
    public boolean isAvailable(boolean toNext) {
        Log.i(TAG, "FontState.isAvailable() called, toNext=" + toNext);
        
        // === 基础条件检查 ===
        
        // 检查1: 当前语言是否支持MiSans
        if (!Utils.isMiSansSupportLanguages()) {
            Log.i(TAG, "FontState: current language not support MiSans");
            return false;
        }
        
        // 检查2: 可用字体列表是否正好2个（Default + MiSans）
        int fontListSize = FontStyleFragment.getFontList(context).size();
        if (fontListSize != 2) {
            Log.i(TAG, "FontState: font list size=" + fontListSize + ", expected 2");
            return false;
        }
        
        // 检查3: 不是折叠屏设备
        if (Utils.isFoldDevice()) {
            Log.i(TAG, "FontState: fold device, skip font page");
            return false;
        }
        
        // 检查4: 不在企业配置模式
        if (Utils.isInProvisionState(context)) {
            Log.i(TAG, "FontState: in provision state, skip font page");
            return false;
        }
        
        // === 🆕 新增检查：用户是否已在Google流程中设置字体 ===
        if (FontStyleUtils.hasSystemFontBeenChanged(context)) {
            Log.i(TAG, "FontState: font already configured in Google Setup, hiding MIUI font page");
            return false;  // 用户已在Google设置过字体，隐藏小米字体页面
        }
        
        Log.i(TAG, "FontState: all checks passed, showing MIUI font page");
        return true;
    }
}
```

##### 第三步：添加FeatureID注释

根据规范，需要在修改的代码处添加FeatureID注释：

```java
// FeatureID: BUGOS2-721450
// 需求：如果用户在Google页面设置过字体，则隐藏小米字体页面
// 实现：通过FontStyleUtils.hasSystemFontBeenChanged()检测系统字体状态
if (FontStyleUtils.hasSystemFontBeenChanged(context)) {
    Log.i(TAG, "FontState: font already configured in Google Setup, hiding MIUI font page");
    return false;
}
// FeatureID: BUGOS2-721450 End
```

##### 第四步：测试验证

###### 测试用例1: Google设置字体后小米页面隐藏

| 步骤 | 操作 | 预期结果 |
|-----|------|---------|
| 1 | 恢复出厂设置 | 设备进入欢迎页 |
| 2 | 进入Google Setup流程 | 显示Google开机设置 |
| 3 | 在Google的"更改文字显示方式"中选择MiSans | Google页面设置成功 |
| 4 | 继续开机流程 | **小米字体设置页面不显示**，直接跳过 |
| 5 | 完成开机引导进入系统 | 系统字体为MiSans |

###### 测试用例2: Google未设置字体则小米页面显示

| 步骤 | 操作 | 预期结果 |
|-----|------|---------|
| 1 | 恢复出厂设置 | 设备进入欢迎页 |
| 2 | 进入Google Setup流程 | 显示Google开机设置 |
| 3 | 在Google的"更改文字显示方式"中保持Default | Google页面未更改字体 |
| 4 | 继续开机流程 | **小米字体设置页面正常显示** |
| 5 | 在小米页面选择MiSans | 字体设置成功 |
| 6 | 完成开机引导进入系统 | 系统字体为MiSans |

###### 测试用例3: Google跳过字体设置

| 步骤 | 操作 | 预期结果 |
|-----|------|---------|
| 1 | 恢复出厂设置 | 设备进入欢迎页 |
| 2 | 进入Google Setup流程并快速跳过所有设置 | Google Setup完成 |
| 3 | 继续开机流程 | **小米字体设置页面正常显示** |
| 4 | 在小米页面选择MiSans或Default | 字体设置成功 |
| 5 | 完成开机引导进入系统 | 系统字体与选择一致 |

###### 测试用例4: 折叠屏/平板设备

| 步骤 | 操作 | 预期结果 |
|-----|------|---------|
| 1 | 在折叠屏或平板设备上恢复出厂设置 | 设备进入欢迎页 |
| 2 | 完成开机流程 | **小米字体设置页面不显示**（符合现有逻辑） |

###### 测试用例5: 不支持MiSans的语言

| 步骤 | 操作 | 预期结果 |
|-----|------|---------|
| 1 | 恢复出厂设置并选择不支持MiSans的语言（如阿拉伯语） | 设备进入欢迎页 |
| 2 | 完成开机流程 | **小米字体设置页面不显示**（符合现有逻辑） |

##### 第五步：日志验证

在开发调试阶段，可以通过日志验证逻辑：

```bash
# 清除日志并启动开机流程
adb logcat -c
adb logcat | grep -E "(FontState|FontStyleUtils)"

# 期望看到的日志（Google设置过字体的情况）：
# FontStyleUtils: Checking if system font has been changed...
# FontStyleUtils: ThemeManager current font ID: 12  (非10表示已更改)
# FontStyleUtils: System font changed detected via ThemeManager
# FontState: font already configured in Google Setup, hiding MIUI font page
# FontState.isAvailable() => false

# 期望看到的日志（Google未设置字体的情况）：
# FontStyleUtils: Checking if system font has been changed...
# FontStyleUtils: ThemeManager current font ID: 10  (10是DEFAULT_FONT_ID)
# FontStyleUtils: No font change detected, system using default font
# FontState: all checks passed, showing MIUI font page
# FontState.isAvailable() => true
```

---

## 📊 风险评估

### 高风险项

| 风险 | 影响 | 缓解措施 |
|-----|------|---------|
| ThemeManager不支持`getCurrentFont`方法 | 无法检测系统字体状态 | 1. 提前调研确认API<br>2. 提供多种检测方法作为备选<br>3. 默认返回false确保向后兼容 |
| Google设置字体后未立即应用到系统 | 检测失败导致误判 | 1. 添加延时检测<br>2. 监听系统字体变更广播 |
| 不同GMS版本实现差异 | 部分设备检测失败 | 1. 多设备测试<br>2. 提供开关控制功能 |

### 中风险项

| 风险 | 影响 | 缓解措施 |
|-----|------|---------|
| 日志输出过多 | 性能影响 | 使用DEBUG级别日志，release版本自动关闭 |
| Settings key不一致 | 检测不准确 | 多方法并行检测，提高容错率 |

### 低风险项

| 风险 | 影响 | 缓解措施 |
|-----|------|---------|
| 用户体验改变 | 用户习惯调整 | 产品评审确认，按需求实施 |

---

## 📝 实施计划

### 第一阶段：调研确认（1天）

- [ ] 确认ThemeManager ContentProvider支持的查询方法
- [ ] 在测试设备上验证Google设置字体的系统行为
- [ ] 确认字体信息的存储位置（Settings/SystemProperties）
- [ ] 评估技术可行性

### 第二阶段：代码实现（2天）

- [ ] 实现`FontStyleUtils.hasSystemFontBeenChanged()`方法
- [ ] 修改`FontState.isAvailable()`逻辑
- [ ] 添加详细日志输出
- [ ] 添加FeatureID注释
- [ ] 代码自测

### 第三阶段：测试验证（2天）

- [ ] 单元测试：验证各种条件分支
- [ ] 集成测试：完整开机流程测试
- [ ] 场景测试：执行上述5个测试用例
- [ ] 多设备测试：不同GMS版本、不同机型
- [ ] 性能测试：确保不影响开机流程性能

### 第四阶段：提交审核（1天）

- [ ] 代码审查
- [ ] 提交Gerrit change
- [ ] 更新测试报告
- [ ] 更新Jira问题单

### 总计：6个工作日

---

## 🔗 相关问题

- **BUGOS2-568848**: O3_W_NJ_国际机型谷歌开机设置MiSans字体，进入小米流程后字体未改变，仍是Default
  - 同类型问题，可能与本需求有关联

---

## 📞 联系人

- **开发**: 李新 (v-lixin88)
- **产品**: 周珊珊 (zhoushanshan5)
- **测试**: 张恩凯 (19720468120)

---

## 📅 更新记录

| 日期 | 版本 | 更新内容 | 更新人 |
|-----|------|---------|--------|
| 2025-10-20 | v1.0 | 初始方案文档 | 李新 |

---

## 附录A：技术调研要点

### 需要确认的API

1. **ThemeManager ContentProvider方法**
   ```java
   // 需要确认是否支持以下方法：
   // - getCurrentFont(): 获取当前系统字体ID
   // - getFonts(): 获取可用字体列表（已确认支持）
   // - applyFont(): 应用字体（已确认支持）
   ```

2. **Settings中的字体相关Key**
   ```java
   // 需要确认以下key是否存在及其用途：
   Settings.System.getString(resolver, "font_id");
   Settings.System.getString(resolver, "theme_font_package");
   Settings.Secure.getString(resolver, "font_config");
   ```

3. **系统属性**
   ```bash
   # 需要确认以下属性的含义：
   persist.sys.font_config
   ro.config.font_type
   ```

### 测试设备要求

- ✅ 国际版ROM
- ✅ 已安装GMS
- ✅ 支持MiSans字体的语言环境
- ✅ 不同GMS版本（建议测试2-3个版本）

---

## 附录B：用户建议评估

**用户建议**:
> 我的建议是，进入谷歌页面并且设置字体后（这个是在GMS里面实现的，能记录到状态吗？），再次进入MIUI的字体设置界面时重写状态机的isAvailable方法是不是就可以了

**评估结果**: ✅ **建议合理且可行**

- ✅ 方向正确：确实应该在`isAvailable()`方法中添加检测逻辑
- ✅ 位置准确：`FontState.isAvailable()`是最佳实施点
- ⚠️ 需要补充：
  1. GMS设置字体的状态**不是直接记录在某个标记中**，而是**应用到了系统字体配置**
  2. 需要通过系统API（如ThemeManager ContentProvider）检测当前字体状态
  3. 不能直接读取GMS的内部状态（无法访问）

**最终实现**: 按照用户建议的思路，在`isAvailable()`中添加检测，但检测方式调整为**查询系统当前字体配置**，而非尝试读取GMS状态。

---

**文档状态**: 待审核  
**下一步**: 进行技术调研，确认ThemeManager API和系统字体存储机制

